```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniCraft 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        canvas { display: block; }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #instructions {
            width: 50%;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-family: sans-serif;
            font-size: 18px;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 10px;
            height: 10px;
            border: 1px solid white;
            background-color: rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
            border-radius: 50%;
            pointer-events: none; /* Important so it doesn't interfere with raycasting */
            display: none; /* Hidden until pointer lock */
        }
        #block-selector {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
            display: flex;
            gap: 5px;
        }
        .block-option {
            width: 40px;
            height: 40px;
            background-size: cover;
            border: 2px solid grey;
            cursor: pointer;
        }
        .block-option.selected {
            border-color: white;
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>MiniCraft 3D</h1>
            <p>Click to play</p>
            <p>(W, A, S, D = Move, SPACE = Jump, SHIFT = Down, MOUSE = Look, CLICK = Place Block, RIGHT CLICK = Break Block)</p>
            <p>Use 1, 2, 3, 4 to select block type</p>
        </div>
    </div>
    <div id="crosshair"></div>
    <div id="block-selector"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let scene, camera, renderer, controls;
        let objects = []; // Store interactable blocks
        let worldObjects = new Map(); // Map position string to mesh
        let playerVelocity = new THREE.Vector3();
        let playerOnGround = false;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        const movementSpeed = 5.0;
        const jumpVelocity = 7.0;
        const gravity = -19.8;
        const playerHeight = 1.8;
        const playerWidth = 0.4; // Half-width for collision detection

        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2(); // Mouse position not needed for pointer lock center

        // Block placement/removal helpers
        let currentBlockType = 'grass'; // Default block
        const rollOverGeo = new THREE.BoxGeometry(1, 1, 1);
        const rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
        const rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);

        // Textures
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            'grass_top': textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/minecraft/grass_top.png'),
            'grass_side': textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/minecraft/grass_side.png'),
            'dirt': textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/minecraft/dirt.png'),
            'stone': textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/minecraft/cobblestone.png'),
            'wood': textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/minecraft/oak_log.png'),
            'leaves': textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/minecraft/oak_leaves.png'),
        };

        // Make textures pixelated
        for (const key in textures) {
            textures[key].magFilter = THREE.NearestFilter;
            textures[key].minFilter = THREE.NearestFilter; // Use NearestFilter for crisp pixels
        }

        const blockMaterials = {
             'grass': [
                new THREE.MeshLambertMaterial({ map: textures['grass_side'] }), // right
                new THREE.MeshLambertMaterial({ map: textures['grass_side'] }), // left
                new THREE.MeshLambertMaterial({ map: textures['grass_top'] }),  // top
                new THREE.MeshLambertMaterial({ map: textures['dirt'] }),      // bottom
                new THREE.MeshLambertMaterial({ map: textures['grass_side'] }), // front
                new THREE.MeshLambertMaterial({ map: textures['grass_side'] })  // back
            ],
            'dirt': new THREE.MeshLambertMaterial({ map: textures['dirt'] }),
            'stone': new THREE.MeshLambertMaterial({ map: textures['stone'] }),
            'wood': new THREE.MeshLambertMaterial({ map: textures['wood'] }),
            'leaves': new THREE.MeshLambertMaterial({ map: textures['leaves'], transparent: true, side: THREE.DoubleSide }), // Enable transparency
        };

        const blockTypes = ['grass', 'dirt', 'stone', 'wood', 'leaves'];
        let selectedBlockIndex = 0;


        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, playerHeight + 5, 10); // Start slightly above ground

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true; // Not implemented fully yet
            scene.add(directionalLight);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            const crosshair = document.getElementById('crosshair');

            instructions.addEventListener('click', () => {
                controls.lock();
            });

            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
                crosshair.style.display = 'block';
            });

            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                instructions.style.display = 'block';
                crosshair.style.display = 'none';
            });

            scene.add(controls.getObject()); // Add camera holder to scene

            // Ground Plane (initial blocks)
            const worldSize = 20; // Size of the flat world grid
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            for (let x = -worldSize / 2; x < worldSize / 2; x++) {
                for (let z = -worldSize / 2; z < worldSize / 2; z++) {
                   addBlock(x, 0, z, 'grass'); // Ground level
                   if (Math.random() < 0.05 && x !== 0 && z !== 0) { // Add some simple trees
                       addTree(x, 1, z);
                   }
                }
            }

            // Roll-over helper
            scene.add(rollOverMesh);

            // Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

             // Block Selector UI
            const blockSelector = document.getElementById('block-selector');
            blockTypes.forEach((type, index) => {
                const option = document.createElement('div');
                option.classList.add('block-option');
                option.dataset.type = type;
                option.style.backgroundImage = `url(${textures[type === 'grass' ? 'grass_side' : type === 'wood' ? 'wood' : type === 'leaves' ? 'leaves' : type].image.src})`;
                if (index === selectedBlockIndex) {
                    option.classList.add('selected');
                }
                option.addEventListener('click', () => {
                    selectBlock(index);
                });
                blockSelector.appendChild(option);
            });
            selectBlock(0); // Initialize selection
        }

        function addBlock(x, y, z, type) {
            const posKey = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
            if (worldObjects.has(posKey)) return; // Don't place if already exists

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            let material;
            if (type === 'grass' && blockMaterials[type]) {
                 material = blockMaterials[type];
            } else if (blockMaterials[type]) {
                 material = blockMaterials[type];
            } else {
                 material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }); // Fallback random color
            }

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(Math.round(x) + 0.5, Math.round(y) + 0.5, Math.round(z) + 0.5); // Center block on grid
            mesh.userData = { type: type, isBlock: true }; // Add custom data
            scene.add(mesh);
            objects.push(mesh); // Add to list for raycasting and collision
            worldObjects.set(posKey, mesh);
        }

         function removeBlock(object) {
            if (!object || !object.userData.isBlock) return;

            const pos = object.position.clone().floor();
            const posKey = `${pos.x},${pos.y},${pos.z}`;

            scene.remove(object);
            objects.splice(objects.indexOf(object), 1);
            worldObjects.delete(posKey);
             // Properly dispose of geometry and material to free memory (optional but good practice)
             if (object.geometry) object.geometry.dispose();
             // Check if material is an array (like grass)
             if (Array.isArray(object.material)) {
                 object.material.forEach(mat => mat.dispose());
             } else if (object.material) {
                 object.material.dispose();
             }
        }

        function addTree(x, y, z) {
            const trunkHeight = Math.floor(Math.random() * 3) + 3; // 3 to 5 blocks high
            // Trunk
            for (let i = 0; i < trunkHeight; i++) {
                addBlock(x, y + i, z, 'wood');
            }
            // Leaves canopy
            const canopyRadius = 2;
            const canopyHeight = y + trunkHeight;
            for (let lx = -canopyRadius; lx <= canopyRadius; lx++) {
                 for (let ly = -1; ly <= 1; ly++) { // Make canopy thicker
                     for (let lz = -canopyRadius; lz <= canopyRadius; lz++) {
                         const distSq = lx*lx + ly*ly + lz*lz;
                         // Place leaves in a roughly spherical shape, not hollow
                         if (distSq <= canopyRadius * canopyRadius && Math.random() > 0.2) {
                              // Avoid placing leaves directly inside trunk column
                              if (lx !== 0 || lz !== 0 || ly >= 0 ) {
                                 addBlock(x + lx, canopyHeight + ly, z + lz, 'leaves');
                              }
                         }
                     }
                 }
            }
             // Top leaf layer
             addBlock(x, canopyHeight + 2, z, 'leaves');
        }

        function selectBlock(index) {
            selectedBlockIndex = index;
            currentBlockType = blockTypes[selectedBlockIndex];
            // Update UI selection indicator
            const options = document.querySelectorAll('.block-option');
            options.forEach((opt, i) => {
                if (i === index) {
                    opt.classList.add('selected');
                } else {
                    opt.classList.remove('selected');
                }
            });
            console.log("Selected block:", currentBlockType);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (playerOnGround) playerVelocity.y = jumpVelocity; break;
                case 'ShiftLeft': case 'KeyC': moveDown = true; break; // Shift or C for down
                 case 'Digit1': selectBlock(0); break;
                 case 'Digit2': selectBlock(1); break;
                 case 'Digit3': selectBlock(2); break;
                 case 'Digit4': selectBlock(3); break;
                 case 'Digit5': selectBlock(4); break; // Assuming 5 block types now
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': case 'KeyC': moveDown = false; break;
            }
        }

        function onMouseDown(event) {
            if (!controls.isLocked) return;

            // Use center of screen for raycasting in PointerLockControls
            pointer.x = 0;
            pointer.y = 0;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false); // Don't check descendants

            if (intersects.length > 0) {
                const intersect = intersects[0];

                // Ensure we didn't click *through* something transparent potentially
                 if (intersect.distance > 0.1) { // Small tolerance

                    if (event.button === 2 || event.ctrlKey) { // Right click or Ctrl+click to remove
                        // Check if intersection point is on the face of the block
                        if (intersect.object.userData.isBlock) {
                             removeBlock(intersect.object);
                        }
                    } else if (event.button === 0) { // Left click to add
                        // Place block adjacent to the clicked face
                        const placementPos = intersect.point.add(intersect.face.normal.multiplyScalar(0.5)).floor();

                        // Check for collision with player before placing
                        const playerPos = controls.getObject().position;
                        const playerBox = new THREE.Box3(
                            new THREE.Vector3(playerPos.x - playerWidth, playerPos.y - playerHeight, playerPos.z - playerWidth),
                            new THREE.Vector3(playerPos.x + playerWidth, playerPos.y, playerPos.z + playerWidth)
                        );
                        const blockBox = new THREE.Box3(
                            new THREE.Vector3(placementPos.x, placementPos.y, placementPos.z),
                            new THREE.Vector3(placementPos.x + 1, placementPos.y + 1, placementPos.z + 1)
                        );

                        if (!playerBox.intersectsBox(blockBox)) {
                            addBlock(placementPos.x, placementPos.y, placementPos.z, currentBlockType);
                        }
                    }
                }
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePlayer(delta) {
            if (!controls.isLocked) return;

            const moveSpeed = movementSpeed * delta;
            const verticalSpeed = (moveUp ? moveSpeed : 0) - (moveDown ? moveSpeed : 0); // Use moveUp/Down for fly mode/crouch

            const moveDirection = new THREE.Vector3();
            camera.getWorldDirection(moveDirection); // Get camera's forward direction
            moveDirection.y = 0; // Keep movement horizontal
            moveDirection.normalize();

            const rightDirection = new THREE.Vector3();
            rightDirection.crossVectors(camera.up, moveDirection).normalize(); // Get camera's right direction

            const currentVelocity = playerVelocity.clone(); // Store current Y velocity

             // Calculate intended movement vector based on input
            const moveVector = new THREE.Vector3(0, 0, 0);
            if (moveForward) moveVector.add(moveDirection);
            if (moveBackward) moveVector.sub(moveDirection);
            if (moveLeft) moveVector.sub(rightDirection);
            if (moveRight) moveVector.add(rightDirection);

            // Apply movement speed, ensure diagonal movement isn't faster
            if (moveVector.lengthSq() > 0) {
                moveVector.normalize().multiplyScalar(moveSpeed);
            }


            // Collision Detection & Resolution
            const playerPos = controls.getObject().position;
            const potentialPos = playerPos.clone().add(moveVector); // Potential horizontal position
             potentialPos.y += (playerVelocity.y + gravity * delta) * delta; // Apply vertical velocity and gravity


            // Simplified Collision Box (Axis-Aligned Bounding Box - AABB)
             const playerBox = new THREE.Box3();
             const targetBox = new THREE.Box3();

             // Check X collision
             playerBox.setFromCenterAndSize(
                 new THREE.Vector3(potentialPos.x, playerPos.y, playerPos.z),
                 new THREE.Vector3(playerWidth * 2, playerHeight, playerWidth * 2)
             );
             let collisionX = false;
             worldObjects.forEach(obj => {
                 targetBox.setFromObject(obj);
                 if (playerBox.intersectsBox(targetBox)) collisionX = true;
             });
             if (collisionX) moveVector.x = 0; // Stop X movement if collision

            // Check Z collision
             playerBox.setFromCenterAndSize(
                  new THREE.Vector3(playerPos.x + moveVector.x, playerPos.y, potentialPos.z), // Use resolved X pos
                 new THREE.Vector3(playerWidth * 2, playerHeight, playerWidth * 2)
             );
              let collisionZ = false;
             worldObjects.forEach(obj => {
                 targetBox.setFromObject(obj);
                 if (playerBox.intersectsBox(targetBox)) collisionZ = true;
             });
             if (collisionZ) moveVector.z = 0; // Stop Z movement if collision


             // Apply horizontal movement *after* collision checks
             controls.moveRight(moveVector.x); // Note: moveRight/moveForward are camera relative
             controls.moveForward(moveVector.z); // So we use them directly here


            // Vertical movement and collision
            playerVelocity.y += gravity * delta; // Apply gravity
            let verticalMove = playerVelocity.y * delta;

             playerBox.setFromCenterAndSize(
                  new THREE.Vector3(playerPos.x + moveVector.x, playerPos.y + verticalMove, playerPos.z + moveVector.z),
                  new THREE.Vector3(playerWidth * 2, playerHeight, playerWidth * 2)
             );

             playerOnGround = false;
             let collisionY = false;
             worldObjects.forEach(obj => {
                 targetBox.setFromObject(obj);
                 if (playerBox.intersectsBox(targetBox)) {
                     collisionY = true;
                     // If falling onto block
                     if (playerVelocity.y < 0) {
                         playerOnGround = true;
                         playerVelocity.y = 0;
                         // Adjust position exactly on top of the block
                         verticalMove = targetBox.max.y - (playerPos.y - playerHeight/2) ; // Difference to top surface
                     } else { // If jumping into block from below
                         playerVelocity.y = 0; // Stop upward movement
                         verticalMove = targetBox.min.y - (playerPos.y + playerHeight/2) ; // Difference to bottom surface
                     }
                 }
             });

             controls.getObject().position.y += verticalMove; // Apply vertical movement


            // Prevent falling through the world floor (y=0 plane in this simple setup)
            if (controls.getObject().position.y < playerHeight / 2) { // Adjust check for center pivot
                playerVelocity.y = 0;
                controls.getObject().position.y = playerHeight / 2;
                playerOnGround = true;
            }


            // Update rollover mesh position
            raycaster.setFromCamera(pointer, camera); // Use center screen pointer
            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                 if (intersect.distance > 0.1 && intersect.face) {
                     // Position rollover cube adjacent to the intersected face
                     const pos = intersect.point.add(intersect.face.normal.multiplyScalar(-0.5)).floor().addScalar(0.5);
                     rollOverMesh.position.copy(pos);
                     rollOverMesh.visible = true;
                 } else {
                     rollOverMesh.visible = false;
                 }
            } else {
                rollOverMesh.visible = false;
            }
        }


        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            updatePlayer(delta);

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
```